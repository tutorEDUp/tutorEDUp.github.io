<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>周界概念模擬器 | Perimeter Simulator</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #f72585;
            --bg: #f8f9fa;
            --card: #ffffff;
            --text: #2b2d42;
            --border: #e9ecef;
            --grid-color: #e0e0e0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* --- 頂部導航 --- */
        header {
            width: 100%;
            background: var(--card);
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo-area {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-area img {
            height: 40px;
            width: auto;
            object-fit: contain;
        }

        .logo-placeholder {
            height: 40px;
            width: 40px;
            background: #ddd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--primary);
        }

        .lang-btn {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lang-btn:hover {
            background: var(--primary);
            color: white;
        }

        /* --- 主要內容區 --- */
        main {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            box-sizing: border-box;
            flex: 1;
        }

        /* 模式切換 Tabs */
        .tabs {
            display: flex;
            background: #e9ecef;
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            text-align: center;
            padding: 10px 5px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            color: #6c757d;
            transition: 0.3s;
            font-size: 0.9rem;
        }

        .tab.active {
            background: var(--card);
            color: var(--primary);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* 畫布區域 */
        .canvas-container {
            background: var(--card);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        canvas {
            max-width: 100%;
            border: 1px dashed #ced4da;
            border-radius: 8px;
            background: transparent;
            position: relative;
            z-index: 2;
        }

        /* 方格背景層 */
        .grid-bg {
            position: absolute;
            top: 20px; /* match padding */
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* match canvas width */
            height: 250px; /* match canvas height */
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px; /* Match scale variable */
            border: 1px solid var(--border);
            border-radius: 8px;
            z-index: 1;
            display: none; /* hidden by default */
        }

        .grid-controls {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .toggle-label {
            font-size: 0.9rem;
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .concept-hint {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #6c757d;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .dot-icon {
            width: 10px;
            height: 10px;
            background: var(--accent);
            border-radius: 50%;
            display: inline-block;
        }

        /* 控制區 */
        .controls {
            background: var(--card);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        .slider-group {
            margin-bottom: 20px;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .value-display {
            color: var(--primary);
            font-family: monospace;
            font-size: 1.1rem;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--primary);
            height: 6px;
            background: #dee2e6;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* 公式與結果 */
        .result-box {
            background: #eef2ff;
            border-left: 4px solid var(--primary);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .formula-row {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            margin: 5px 0;
            color: #333;
            word-wrap: break-word;
        }

        .final-result {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            margin-top: 10px;
        }

        .highlight-l { color: #4361ee; font-weight: bold; }
        .highlight-w { color: #f72585; font-weight: bold; }
        
        footer {
            margin-top: auto;
            padding: 20px;
            text-align: center;
            font-size: 0.8rem;
            color: #aaa;
        }
    </style>
</head>
<body>

<header>
    <div class="logo-area">
        <img src="logo.png" alt="App Logo" onerror="this.style.display='none'; document.querySelector('.logo-placeholder').style.display='flex'">
        <div class="logo-placeholder" style="display:none;">LOGO</div>
        <h1 id="app-title">周界概念模擬器</h1>
    </div>
    <button class="lang-btn" onclick="toggleLang()" id="lang-btn">EN</button>
</header>

<main>
    <!-- 切換模式 -->
    <div class="tabs">
        <div class="tab active" onclick="setMode('rect')" id="tab-rect">長方形</div>
        <div class="tab" onclick="setMode('square')" id="tab-square">正方形</div>
        <div class="tab" onclick="setMode('simple')" id="tab-simple">簡單圖形</div>
    </div>

    <!-- 視覺展示區 -->
    <div class="canvas-container">
        <div class="grid-bg" id="grid-bg"></div>
        <canvas id="geoCanvas" width="300" height="250"></canvas>
        
        <div class="grid-controls">
            <label class="toggle-label">
                <input type="checkbox" id="grid-toggle" onchange="toggleGrid()"> 
                <span id="label-grid">顯示方格 (量度)</span>
            </label>
        </div>

        <div class="concept-hint">
            <span class="dot-icon"></span>
            <span id="concept-text">紅點移動的軌跡就是周界</span>
        </div>
    </div>

    <!-- 控制與計算區 -->
    <div class="controls">
        
        <!-- 長方形控制器 -->
        <div id="controls-rect">
            <div class="slider-group">
                <div class="label-row">
                    <span id="label-l" style="color: var(--primary)">長 (Length)</span>
                    <span class="value-display" id="val-l">10</span>
                </div>
                <input type="range" id="input-l" min="2" max="12" value="10" oninput="updateSim()">
            </div>
            <div class="slider-group">
                <div class="label-row">
                    <span id="label-w" style="color: var(--accent)">闊 (Width)</span>
                    <span class="value-display" id="val-w">6</span>
                </div>
                <input type="range" id="input-w" min="2" max="10" value="6" oninput="updateSim()">
            </div>
        </div>

        <!-- 正方形控制器 -->
        <div id="controls-square" style="display: none;">
            <div class="slider-group">
                <div class="label-row">
                    <span id="label-s">邊長 (Side)</span>
                    <span class="value-display" id="val-s">8</span>
                </div>
                <input type="range" id="input-s" min="2" max="10" value="8" oninput="updateSim()">
            </div>
        </div>

        <!-- 簡單圖形 (L-Shape) 控制器 -->
        <div id="controls-simple" style="display: none;">
            <div style="font-size: 0.9rem; color:#666; margin-bottom:15px;" id="desc-simple">拖動改變圖形大小，周界是所有邊長的總和。</div>
            <div class="slider-group">
                <div class="label-row">
                    <span id="label-h-simple" style="color: var(--primary)">總高度 (Height)</span>
                    <span class="value-display" id="val-h-simple">8</span>
                </div>
                <input type="range" id="input-h-simple" min="4" max="10" value="8" oninput="updateSim()">
            </div>
            <div class="slider-group">
                <div class="label-row">
                    <span id="label-w-simple" style="color: var(--accent)">總闊度 (Width)</span>
                    <span class="value-display" id="val-w-simple">8</span>
                </div>
                <input type="range" id="input-w-simple" min="4" max="12" value="8" oninput="updateSim()">
            </div>
        </div>

        <!-- 結果顯示 -->
        <div class="result-box">
            <div id="formula-text" style="font-size: 0.9rem; color: #666; margin-bottom: 5px;">公式：</div>
            <div class="formula-row" id="formula-display">
                <!-- Javascript will render this -->
            </div>
            <div class="final-result" id="result-display">
                P = 32
            </div>
        </div>
    </div>
</main>

<footer>
    &copy; Concept Simulator. Designed for Learning.
</footer>

<script>
    // --- 語言設定 ---
    const i18n = {
        zh: {
            title: "周界概念模擬器",
            tabRect: "長方形",
            tabSquare: "正方形",
            tabSimple: "簡單圖形",
            hint: "紅點移動的軌跡就是周界",
            labelGrid: "顯示方格 (量度)",
            labelL: "長度 (Length)",
            labelW: "闊度 (Width)",
            labelS: "邊長 (Side)",
            labelHSimple: "總高度",
            labelWSimple: "總闊度",
            descSimple: "簡單圖形的周界是所有邊長的總和 (例如 L 形)。",
            formulaLabel: "周界公式：",
            resultPrefix: "周界",
            btn: "EN"
        },
        en: {
            title: "Perimeter Simulator",
            tabRect: "Rectangle",
            tabSquare: "Square",
            tabSimple: "Simple Shape",
            hint: "The path of the red dot is the perimeter",
            labelGrid: "Show Grid (Measure)",
            labelL: "Length",
            labelW: "Width",
            labelS: "Side",
            labelHSimple: "Total Height",
            labelWSimple: "Total Width",
            descSimple: "Perimeter is the sum of all sides.",
            formulaLabel: "Formula:",
            resultPrefix: "Perimeter",
            btn: "中"
        }
    };

    let curLang = 'zh';
    let curMode = 'rect'; // 'rect', 'square', 'simple'
    
    // Canvas 設定
    const canvas = document.getElementById('geoCanvas');
    const ctx = canvas.getContext('2d');
    const scale = 20; // 1 unit = 20px
    
    // 動畫狀態
    let animProgress = 0;
    
    // L-Shape constant proportions (cutout size)
    const cutH = 2; 
    const cutW = 2;

    // --- 初始化 ---
    function init() {
        updateSim();
        animate();
    }

    // --- 顯示方格 ---
    function toggleGrid() {
        const bg = document.getElementById('grid-bg');
        const check = document.getElementById('grid-toggle');
        bg.style.display = check.checked ? 'block' : 'none';
    }

    // --- 語言切換邏輯 ---
    function toggleLang() {
        curLang = curLang === 'zh' ? 'en' : 'zh';
        applyLang();
        updateSim();
    }

    function applyLang() {
        const t = i18n[curLang];
        document.getElementById('app-title').innerText = t.title;
        document.getElementById('lang-btn').innerText = t.btn;
        document.getElementById('tab-rect').innerText = t.tabRect;
        document.getElementById('tab-square').innerText = t.tabSquare;
        document.getElementById('tab-simple').innerText = t.tabSimple;
        document.getElementById('concept-text').innerText = t.hint;
        document.getElementById('label-grid').innerText = t.labelGrid;
        
        document.getElementById('label-l').innerText = t.labelL;
        document.getElementById('label-w').innerText = t.labelW;
        document.getElementById('label-s').innerText = t.labelS;
        
        document.getElementById('label-h-simple').innerText = t.labelHSimple;
        document.getElementById('label-w-simple').innerText = t.labelWSimple;
        document.getElementById('desc-simple').innerText = t.descSimple;
        
        document.getElementById('formula-text').innerText = t.formulaLabel;
    }

    // --- 模式切換 ---
    function setMode(mode) {
        curMode = mode;
        // UI 更新
        document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
        document.getElementById('tab-' + mode).classList.add('active');
        
        document.getElementById('controls-rect').style.display = 'none';
        document.getElementById('controls-square').style.display = 'none';
        document.getElementById('controls-simple').style.display = 'none';

        if (mode === 'rect') {
            document.getElementById('controls-rect').style.display = 'block';
        } else if (mode === 'square') {
            document.getElementById('controls-square').style.display = 'block';
        } else {
            document.getElementById('controls-simple').style.display = 'block';
        }
        updateSim();
    }

    // --- 核心邏輯更新 ---
    function updateSim() {
        let L, W, S, P;
        const htmlFormula = document.getElementById('formula-display');
        const htmlResult = document.getElementById('result-display');
        const t = i18n[curLang];

        if (curMode === 'rect') {
            L = parseInt(document.getElementById('input-l').value);
            W = parseInt(document.getElementById('input-w').value);
            P = (L + W) * 2;
            
            document.getElementById('val-l').innerText = L;
            document.getElementById('val-w').innerText = W;
            
            htmlFormula.innerHTML = `(<span class="highlight-l">${L}</span> + <span class="highlight-w">${W}</span>) × 2`;

        } else if (curMode === 'square') {
            S = parseInt(document.getElementById('input-s').value);
            P = S * 4;
            
            document.getElementById('val-s').innerText = S;
            htmlFormula.innerHTML = `<span class="highlight-l">${S}</span> × 4`;

        } else if (curMode === 'simple') {
            // L-Shape logic
            let totalH = parseInt(document.getElementById('input-h-simple').value);
            let totalW = parseInt(document.getElementById('input-w-simple').value);
            
            // Define L-shape sides
            // Top segment (horizontal)
            let s1 = totalW - cutW; 
            // Inner vertical
            let s2 = cutH; 
            // Inner horizontal
            let s3 = cutW;
            // Right vertical (full height)
            let s4 = totalH;
            // Bottom horizontal (full width)
            let s5 = totalW;
            // Left vertical (height - cut)
            let s6 = totalH - cutH;

            // Simple shapes usually calculate by adding all sides
            P = s1 + s2 + s3 + s4 + s5 + s6;

            document.getElementById('val-h-simple').innerText = totalH;
            document.getElementById('val-w-simple').innerText = totalW;
            
            // Formula display: s1+s2+s3+s4+s5+s6
            htmlFormula.innerHTML = `<small>${s6} + ${s1} + ${s2} + ${s3} + ${s4} + ${s5}</small>`;
        }
        
        htmlResult.innerText = `${t.resultPrefix} = ${P}`;
    }

    // --- Canvas 繪圖與動畫 ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Define shape path points based on mode
        let points = []; // Array of {x, y}
        let w, h;
        let startX, startY;

        if (curMode === 'rect') {
            w = parseInt(document.getElementById('input-l').value) * scale;
            h = parseInt(document.getElementById('input-w').value) * scale;
            startX = (canvas.width - w) / 2;
            startY = (canvas.height - h) / 2;
            
            points = [
                {x: startX, y: startY},         // Top-left
                {x: startX + w, y: startY},     // Top-right
                {x: startX + w, y: startY + h}, // Bottom-right
                {x: startX, y: startY + h}      // Bottom-left
            ];

        } else if (curMode === 'square') {
            w = parseInt(document.getElementById('input-s').value) * scale;
            h = w;
            startX = (canvas.width - w) / 2;
            startY = (canvas.height - h) / 2;

            points = [
                {x: startX, y: startY},
                {x: startX + w, y: startY},
                {x: startX + w, y: startY + h},
                {x: startX, y: startY + h}
            ];

        } else if (curMode === 'simple') {
            // L-Shape
            let totalH = parseInt(document.getElementById('input-h-simple').value) * scale;
            let totalW = parseInt(document.getElementById('input-w-simple').value) * scale;
            let cW = cutW * scale;
            let cH = cutH * scale;

            w = totalW; h = totalH;
            startX = (canvas.width - w) / 2;
            startY = (canvas.height - h) / 2;

            // Draw L-shape clockwise starting from top-left (ish)
            // Let's start from Top-Left corner of the 'block' but indented
            // Points order: Top-Left(indent), Inner-Corner, Top-Right(indent), Bottom-Right, Bottom-Left, Left-Top
            
            // Let's do Standard "L"
            // P1: Top-Left of vertical bar
            // P2: Top-Right of vertical bar (inner corner top)
            // P3: Inner corner
            // P4: Top-Right of horizontal bar
            // P5: Bottom-Right
            // P6: Bottom-Left
            
            // Coordinate mapping:
            let x1 = startX; 
            let y1 = startY;
            
            points = [
                {x: startX, y: startY}, // Top-Left
                {x: startX + (totalW - cW), y: startY}, // Top-Right of vertical part (top edge)
                {x: startX + (totalW - cW), y: startY + cH}, // Inner corner vertical
                {x: startX + totalW, y: startY + cH}, // Inner corner horizontal -> Right Edge
                {x: startX + totalW, y: startY + totalH}, // Bottom Right
                {x: startX, y: startY + totalH} // Bottom Left
            ];
            
            // For logic below, we need a closed loop, so we add the first point at end implicitly or handle logic
        }

        // 1. Fill Shape
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = 'rgba(67, 97, 238, 0.1)';
        ctx.fill();

        // 2. Stroke Static Border
        ctx.strokeStyle = '#ddd';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.setLineDash([]);

        // 3. Draw Side Labels (Static)
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Helper to place text mid-line
        const labelText = (txt, pA, pB) => {
            let mx = (pA.x + pB.x) / 2;
            let my = (pA.y + pB.y) / 2;
            // Offset slightly
            if(pA.x === pB.x) mx += (pA.x < startX + w/2) ? -15 : 15; // Vertical line
            if(pA.y === pB.y) my += (pA.y < startY + h/2) ? -15 : 15; // Horizontal line
            ctx.fillText(txt, mx, my);
        }

        if(curMode === 'simple') {
            // Label all 6 sides
            const vals = [
                parseInt(document.getElementById('input-w-simple').value) - cutW,
                cutH,
                cutW,
                parseInt(document.getElementById('input-h-simple').value),
                parseInt(document.getElementById('input-w-simple').value),
                parseInt(document.getElementById('input-h-simple').value) - cutH
            ];
            for(let i=0; i<points.length; i++) {
                let next = (i+1) % points.length;
                labelText(vals[i], points[i], points[next]);
            }
        } else {
            // Label Rect/Square
            let valL = curMode === 'rect' ? document.getElementById('input-l').value : document.getElementById('input-s').value;
            let valW = curMode === 'rect' ? document.getElementById('input-w').value : document.getElementById('input-s').value;
            // Top
            ctx.fillText(valL, (points[0].x + points[1].x)/2, points[0].y - 15);
            // Right
            ctx.fillText(valW, points[1].x + 15, (points[1].y + points[2].y)/2);
        }

        // 4. Animation Logic
        // Calculate total pixels
        let totalDistPx = 0;
        let segmentLengths = [];
        for(let i=0; i<points.length; i++){
            let next = (i+1) % points.length;
            let dx = points[next].x - points[i].x;
            let dy = points[next].y - points[i].y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            segmentLengths.push(dist);
            totalDistPx += dist;
        }

        let travelDist = (animProgress / 100) * totalDistPx;
        let currentTravel = 0;
        
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        
        // Trace logic
        let penX = points[0].x;
        let penY = points[0].y;
        
        // Find which segment we are on
        for(let i=0; i<points.length; i++) {
            let next = (i+1) % points.length;
            let segLen = segmentLengths[i];
            
            // Color logic: alternating for visual distinction
            ctx.strokeStyle = (i % 2 === 0) ? '#4361ee' : '#f72585';
            if(curMode === 'square') ctx.strokeStyle = '#4361ee';

            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);

            if (travelDist >= currentTravel + segLen) {
                // Full segment drawn
                ctx.lineTo(points[next].x, points[next].y);
                ctx.stroke();
                currentTravel += segLen;
            } else {
                // Partial segment
                let remaining = travelDist - currentTravel;
                let ratio = remaining / segLen;
                let endX = points[i].x + (points[next].x - points[i].x) * ratio;
                let endY = points[i].y + (points[next].y - points[i].y) * ratio;
                
                ctx.strokeStyle = '#f72585'; // Active color
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Draw Dot
                ctx.beginPath();
                ctx.arc(endX, endY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#f72585';
                ctx.fill();
                
                break; // Stop loop once dot is drawn
            }
        }
    }

    // 動畫循環
    function animate() {
        animProgress += 0.2;
        if (animProgress > 100) animProgress = 0;
        draw();
        requestAnimationFrame(animate);
    }

    init();

</script>
</body>
</html>
